/*Лабораторная работа 3
Описать иерархию классов: точка (целые координаты), прямая наследует точку, являющуюся ее началом,
куб наследует прямую, являющуюся его ребром. Реализовать методы: конструкторы классов без параметров, 
конструкторы классов с параметрами, функции вывода значений закрытых полей данных, функции доступа к закрытым данным,
виртуальные функции вычисления какого-либо значения: для класса точка возвращает нуль, для класса прямая возвращает
длину отрезка(√ ((X2-X1)²+(Y2-Y1)²).), для класса куб возвращает его площадь  поверхности; виртуальные деструкторы.
Для третьего класса иерархии выполнить:
1. Перегрузить операцию сравнения (>) с тем, чтобы можно было cравнивать объекты класса куб, описанного в лабораторной
работе №3 (функция должна возвращать куб с большей площадью поверхности).
2. Перегрузить также операцию вывода << (включения в выходной поток) так,
чтобы можно было включать в поток объекты класса куб и выводить результаты
умножения (данные класса и значение, возвращенное виртуальной функцией). При этом параметрами перегруженной
операции должны быть поток ostream (по ссылке) и объект класса куб (по ссылке). Фактическим параметром,
соответствующим параметру типа ostream, может быть cout или текстовый файл.
*/


#include <iostream>
#include <cmath>
#include <fstream>

using namespace std;


class Cpoint
{
protected://захищені дані protected — Модификатор доступа, который определяет, что программист собирается применить наследование. В наследуемых классах он собирается унаследовать такие элементы, которые должны срабатывать как элементы private, но в отличии от private они расплодятся по всем наследникам и каждый такой элемент будет соответствовать только своему классу
	int x;//координата x
	int y; //координата y
public: //відкриті методи

	
	Cpoint(int Value1, int Value2)	//конструктор c параметрами
	{
		x = Value1;//присвоєння приватному полю значення
		y = Value2;
		cout << "Работа конструктора Cpoint, c параметрами при создании нового объекта: " << endl;//и здесь же их отобразим на экран
		cout << "x = " << x << endl;
		cout << "y = " << y << endl;

	}
	Cpoint()
	{
		x = 0;//присвоим начальные значения переменным
		y = 0;
		cout << "Работа конструктора Cpoint,без параметров при создании нового объекта: " << endl;//и здесь же их отобразим на экран
		cout << "x = " << x << endl;
		cout << "y = " << y << endl;
	}

	virtual ~Cpoint() { cout << "Тут сработал деструктор Cpoint" << endl; } // деструктор

	int PublicMethodX(void)	//загальний (відкритий) метод
	{
		cout << "\n Открытый метод Cpoint возвращает private поле x=" << x << endl;
		return x;	//повертає приватне поле
	}
	int PublicMethodY(void)	//загальний (відкритий) метод
	{
		cout << "\n Открытый метод Cpoint возвращает private поле y=" << y << endl;
		return y;	//повертає приватне поле
	}
	
	//int getx() { return x; }
	//int gety() { return y; }
	virtual double area() const { cout << "Тут сработала функция area() для Cpoint" << endl; return 0; };//	Функція обчислення площі (Виртуальная функция — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить. Виртуальная функция вызывается только через указатель или ссылку на базовый класс.)
	void Show()//виведення об’єкта
	{
		cout << "\n Тут сработала функция Show() для Cpoint" << endl;
		cout << "x1 =" << x << endl;
		cout << "y1 =" << y << endl;
	}
};

class Cline: public Cpoint
{
protected://захищені дані
	int x2;//координата x
	int y2; //координата y
public: //відкриті методи


	Cline(int Value1, int Value2, int Value3, int Value4)
	{
		x = Value1;//присвоєння приватному полю значення
		y = Value2;
		x2 = Value3;//присвоєння приватному полю значення
		y2 = Value4;
		cout << "Работа конструктора , c параметрами при создании нового объекта Cline или Сube: " << endl;//и здесь же их отобразим на экран
		cout << "x1 = " << x << endl;
		cout << "y1 = " << y << endl;
		cout << "x2 = " << x2 << endl;
		cout << "y2 = " << y2 << endl;

	};
	Cline()
	{
		x = 0;//присвоим начальные значения переменным
		y = 0;
		x2 = 1;//присвоєння приватному полю значення
		y2 = 1;
		cout << "Работа конструктора ,без параметров при создании нового объекта Cline или Сube: " << endl;//и здесь же их отобразим на экран
		cout << "x1 = " << x << endl;
		cout << "y1 = " << y << endl;
		cout << "x2 = " << x2 << endl;
		cout << "y2 = " << y2 << endl;

	};

	~Cline() { cout << "Тут сработал деструктор Cline" << endl; }

	//int getx2() { return x2; }
	//int gety2() { return y2; }

	virtual double area() const { cout << "Тут сработала функция area() для Cline"<< endl;  return sqrt((x2 - x)*(x2 - x) + (y2 - y)*(y2 - y)); };//	Функція обчислення площі
	//виведення об’єкта
	void Show()//виведення об’єкта
	{
		cout << "\n Тут сработала функция Show() для Cline" << endl;
		cout << "x1 =" << x << endl;
		cout << "y1 =" << y << endl;
		cout << "x2 =" << x2 << endl;
		cout << "y2 =" << y2 << endl;

	}
};


class Cube : public Cline
{
protected://захищені дані
public: //відкриті методи
	

	Cube(int Value1, int Value2, int Value3, int Value4) : Cline(Value1,Value2,Value3,Value4) {}
	Cube() : Cline() {}   // конструктор класса Cube вызывает конструктор класса Cline
	~Cube() { cout << "Тут сработал деструктор Cube" << endl; }
	Cube operator>(Cube &t)
	{
		cout << "Тут сработала перезагрузка операции >\n";
		if (area() > t.area())
			return *this;
		else
			return t;
	}
	double area() const { cout << "Тут сработала функция area() для Cube" << endl;return 6 * Cline::area()* Cline::area(); };//	Функція обчислення площі поверхні
	void Show()//виведення об’єкта
	{
		cout << "\n Тут сработала функция Show() для Cube" << endl;
		cout << "x1 =" << x << endl;
		cout << "y1 =" << y << endl;
		cout << "x2 =" << x2 << endl;
		cout << "y2 =" << y2 << endl;

	}
	
	friend ostream& operator<<(ostream& outs,const  Cube& xCube)// Дружня функція
	{
		outs << "Работа функции перегрузка операции вывода << (включения в выходной поток)"<< "\n";
		outs <<"x1=" <<xCube.x << "\n";
		outs << "y1=" << xCube.y << "\n";
		outs << "x2=" << xCube.x2 << "\n";
		outs << "y2=" << xCube.y2 << "\n";
		if (xCube.x == xCube.x2 && xCube.y == xCube.y2)outs <<"S = 0\n";
		outs << "S="<< xCube.area();
		return outs;
	}
};

double area_(Cpoint &r) {
	return r.area();
}

int main()
{
	setlocale(LC_ALL, "Russian");
	Cpoint base_obj;
	Cline first_obj;
	Cube second_obj(1,2,3,4);
	Cube third_obj(8,10,100,15);

	base_obj.PublicMethodX();
	area_(base_obj);
	area_(first_obj); 
	area_(second_obj); 

	cout <<"Длина отрезка first_obj= " <<area_(first_obj) << endl;

	
	cout << third_obj << endl;

	
	(third_obj > second_obj).Show();

	return 0;
}